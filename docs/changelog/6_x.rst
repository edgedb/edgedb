
v6.0
====

:edb-alt-title: EdgeDB v6

To play with the new features, make sure to specify version 6.0 when
initializing the project as pre-release versions are not considered stable
and will not be automatically suggested:

.. code-block:: bash

  $ edgedb project init --server-version 6.0-beta.1


Upgrading
=========

**Local and Cloud instances**

To upgrade a local project, first ensure that your CLI is up to date with
``edgedb cli upgrade``. Then run the following command inside the project
directory.

.. code-block:: bash

  $ edgedb project upgrade --to-testing

Alternatively, specify an instance name if you aren't using a project.

.. code-block:: bash

  $ edgedb instance upgrade -I my_instance

The CLI will first check to see if your schema will migrate cleanly to EdgeDB
6.0. If the upgrade check finds any problems, it will report them back to you.

**Hosted instances**

To upgrade a remote (hosted) instance, we recommend the following
dump-and-restore process.

1. EdgeDB v6.0 supports PostgreSQL 14 (or above). So check the version of
   PostgreSQL you are using before upgrading EdgeDB. If you're using Postgres
   13 or below, you should upgrade Postgres first.

2. Spin up an empty 6.0 instance. You can use one of our :ref:`deployment
   guides <ref_guide_deployment>`.

   Under Debian/Ubuntu, when adding the EdgeDB package repository, use this
   command instead:

   .. code-block:: bash

       $ echo deb [signed-by=/usr/local/share/keyrings/edgedb-keyring.gpg] \
           https://packages.edgedb.com/apt \
           $(grep "VERSION_CODENAME=" /etc/os-release | cut -d= -f2) main \
           | sudo tee /etc/apt/sources.list.d/edgedb.list

   Use this command for installation under Debian/Ubuntu:

   .. code-block:: bash

       $ sudo apt-get update && sudo apt-get install edgedb-6

   Under CentOS/RHEL, use this installation command:

   .. code-block:: bash

       $ sudo yum install edgedb-6

   In any required ``systemctl`` commands, replace ``edgedb-server-6`` with
   ``edgedb-server-6``.

   Under any Docker setups, supply the ``6.0`` tag.

3. Take your application offline, then dump your v4.x database with the CLI

   .. code-block:: bash

       $ edgedb dump --dsn <old dsn> --all --format dir my_database.dump/

   This will dump the schema and contents of your current database to a
   directory on your local disk called ``my_database.dump``. The directory name
   isn't important.

4. Restore the empty v6.x instance from the dump

   .. code-block:: bash

       $ edgedb restore --all my_database.dump/ --dsn <new dsn>

   Once the restore is complete, update your application to connect to the new
   instance.

   This process will involve some downtime, specifically during steps 2 and 3.


New features
============

SQL write support
-----------------

You can now use SQL DML (``insert``, ``update``, ``delete``) when connecting to
your EdgeDB instance via the PostgreSQL protocol. Our aim is to support most
typical use cases from tools like SQL ORMs and SQL clients.

Our aim is to allow even more developers to use EdgeDB, taking advantage of our
advanced data model, tooling, and high-performance connection management. Teams
can migrate their existing SQL codebases to EdgeDB without having to rewrite
their queries. Once you've adopted EdgeDB, you can start to take advantage of
EdgeQL's powerful query capabilities piece by piece.

There are also some benefits to existing EdgeDB users who are already using
EdgeQL. There are a number of SQL features that we still do not support, such
as window functions, recursive queries, and explicit locking. You can now use
these features in SQL today, and we will continue to add support for more
features in the future.

In-place upgrade
----------------

Our hope is this version will be the last one to require a full dump and
restore process to when upgrading major versions. We know that dump-and-restore
is a disruptive process, so our hope is that allowing in-place upgrades will
make it easier for teams to upgrade more frequently.

``ext::postgis``
----------------

We've added support for the popular PostGIS extension for PostgreSQL. This
extension adds support for geographic objects and spatial data types.

``std::net``
------------

We've introduced a new standard library module for sending network requests.
Our first target is support for HTTP. This module will schedule asynchronous
requests and allow you to poll for the response.

``ext::auth``
-------------

We've introduced a number of new features to our authentication extension.

- You can now configure generic OpenID Connect providers.
- If you are using an OAuth provider that returns an ``id_token`` (like an
  OpenID Connect compatible provider), you will now receive that validated
  token in your callback. This will make it easier to use some of that data
  for your own User or Profile objects and save a roundtrip to the identity
  provider.
- As an alternative (or in addition) to configuring SMTP for sending emails,
  you can now configure a webhook for the various authentication lifecycle
  events. You can use these webhooks to send custom emails, update analytics,
  or trigger other workflows.
- We've treated a missing PKCE session during email verification as an error,
  but we will now support verifying end-user emails from a different device
  than the one that started the sign-up or sign-in flow. To support
  verification without PKCE, you will now direct the end-user to attempt a
  login after they've verified their email, which will start a new flow.
  Previously, you would have no way to know if a sign-in attempt is really an
  "interrupted" sign-up attempt, and could not know when to make your own
  ``User`` type. Now, on sign up, even if you require email verification, we
  will return an ``identity_id`` in the sign up response, so you can create
  your own ``User`` type before the email has been verified.
- We now configure a development-only SMTP provider for instances hosted on
  our Cloud. This SMTP proxy is heavily rate limited, and requires a fixed
  sender email address. It is intended to be used for development and testing
  purposes. Once you're ready to start sending real emails, you can configure
  your own SMTP provider. We hope this will make it easier to get started with
  a simple email-based authentication flow during early development.

Breaking changes

- We have moved our SMTP configuration into a new top-level
  ``Config::SMTPProvider`` configuration object. During the upgrade process,
  your existing SMTP configuration will be migrated to this new object, but if
  you have any scripts that configure SMTP directly, you will need to update
  them to use the new object.

``ext::ai``
-----------

- We've updated the built-in list of models from our first-party LLM providers
  to match the latest offerings from OpenAI, Anthropic, and Mistral.
- We now pass LLM configuration query parameters through to the downstream
  provider.

Additional changes
==================


Bug fixes
---------
