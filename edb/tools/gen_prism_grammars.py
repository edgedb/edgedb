#
# This source file is part of the EdgeDB open source project.
#
# Copyright 2019-present MagicStack Inc. and the EdgeDB authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#


import sys
import click

from edb.edgeql.parser.grammar import keywords as eql_keywords
from edb.eschema.parser.grammar import keywords as eschema_keywords
from edb.tools.edb import edbcommands

import edgedb


BOOL_LITERALS = ['true', 'false']
CONTAINER_TYPES = ['array', 'tuple']


def die(msg):
    print(f'FATAL: {msg}', file=sys.stderr)
    sys.exit(1)


def main(*, stdout: bool, out_fn: str):
    code = [
        f'// AUTOGENERATED BY EdgeDB WITH\n'
        f'//    $ edb gen-prism-grammars'
        f'\n\n\n'
    ]

    # add common reserved keywords
    code.append(f'var reserved_keywords = [\n')
    code.extend([f'  "{kw}",\n' for kw in
                 sorted(eql_keywords.reserved_keywords)
                 if kw not in BOOL_LITERALS])
    code.append(f'];\n\n')
    # add common eschema-specific keywords
    code.append(f'var eschema_keywords = reserved_keywords.concat([\n')
    code.extend([f'  "{kw}",\n' for kw in
                 sorted(eschema_keywords.unreserved_keywords)
                 if kw not in BOOL_LITERALS])
    code.append(f']);\n\n')
    # add common edgeql-specific keywords
    code.append(f'var edgeql_keywords = reserved_keywords.concat([\n')
    code.extend([f'  "{kw}",\n' for kw in
                 sorted(eql_keywords.unreserved_keywords)
                 if kw not in BOOL_LITERALS])
    code.append(f']);\n\n')

    con = edgedb.connect(user='edgedb', database='edgedb')

    # add builtins
    types = list(con.fetch('''
        WITH
            MODULE schema,
            T := (SELECT Type
                  FILTER Type IS (PseudoType | ScalarType | ObjectType))
        SELECT T.name[5:]
        FILTER T.name LIKE 'std::%';
    '''))
    constraints = list(con.fetch(r'''
        # NOTE: currently there's a constraint called
        # 'std::constraint' that makes it into the list and cannot be
        # filtered out based on any specific parameter.
        WITH
            MODULE schema,
            name := DISTINCT `Constraint`.name
        SELECT cname :=
            re_match(r'(?:std|sys|math)::([a-zA-Z]\w+$)', name)[0]
        FILTER cname != 'constraint';
    '''))

    common_builtins = types + constraints + CONTAINER_TYPES
    common_builtins.sort()

    fn_builtins = list(con.fetch(r'''
        WITH
            MODULE schema,
            name := DISTINCT `Function`.name
        SELECT re_match(r'(?:std|sys|math)::([a-zA-Z]\w+$)', name)[0];
    '''))
    fn_builtins.sort()

    code.append(f'var common_builtins = [\n')
    code.extend([f'  "{kw}",\n' for kw in common_builtins])
    code.append(f'];\n\n')

    code.append(f'var edgeql_builtins = common_builtins.concat([\n')
    code.extend([f'  "{kw}",\n' for kw in fn_builtins
                 if kw not in common_builtins])
    code.append(f']);\n\n')

    # add bool literals
    code.append(f'var bool_literals = [\n')
    code.extend([f'  "{kw}",\n' for kw in BOOL_LITERALS])
    code.append(f'];\n\n')

    # add non-word operators

    operators = list(con.fetch(r'''
        WITH MODULE schema
        SELECT _ := DISTINCT Operator.name[5:]
        FILTER not re_test(r'^[a-zA-Z ]+$', _)
        ORDER BY _;
    '''))
    # escape every operator symbol
    operators = [R'\\' + R'\\'.join(op) for op in operators]
    code.append(f'var operators = [\n')
    code.extend([f'  "{kw}",\n' for kw in operators])
    code.append(f'];\n\n')

    code.append(r'''
var shared_grammar = {
  'comment': /#.*/,

  'string': [
      {
        pattern: /(['"])(?:\\['"]|[\n\r]|.)*?\1/,
        greedy: true,
      },
      {
        pattern: /(\$([A-Za-z\200-\377_][0-9]*)*\$)(?:[\n\r]|.)*\1/,
        greedy: true,
      },
  ],

  'code': /`.+?`|\.</,

  'number': [
    {
      pattern: /(\W)(?:\d+(?:\.\d+)?(?:[eE](?:[+\-])?[0-9]+))|(?:\d+\.\d+)/,
      lookbehind: true,
    },
    {
      pattern: /(\W)\d+/,
      lookbehind: true,
    },
  ],

  'definition': {
    pattern: /:=|->/,
    alias: 'punctuation',
  },

  'boolean':
    RegExp('\\b(?:' + bool_literals.join('|') + ')\\b', 'i'),

  'builtin': RegExp('\\b(?:' + common_builtins.join('|') + ')\\b')
};

var shared_synopsis_grammar = {
  'synopsis-text': {
    pattern: /#([^\n]*)/,
    greedy: true,

    inside: {
      'synopsis-placeholder': {
        pattern: /<[\w\-]+>/,
      },
    }
  },

  'synopsis-placeholder': {
    pattern: /<[\w\-]+>/,
  },

  'string': {
    pattern: /(['"])(?:\\['"]|[\n\r]|.)*?\1/,
    greedy: true,
  },

  'optional': [
    /\[|\]|\{|\}/,
    /\.\.\./,
    /,/,
  ],

  'group': /[{}|]/,
}

Prism.languages.eschema = Object.assign({}, shared_grammar, {
  'keyword':
    RegExp('\\b(?:' + eschema_keywords.join('|') + ')\\b'),
});

Prism.languages.edgeql = Object.assign({}, shared_grammar, {
  'operator':
    RegExp(operators.join('|')),

  'linkprop': {
    pattern: /@\w+/,
  },

  'variable': /\$[\w\d]+/,

  'keyword':
    RegExp('\\b(?:' + edgeql_keywords.join('|') + ')\\b', 'i'),

  'builtin': RegExp('\\b(?:' + edgeql_builtins.join('|') + ')\\b')
});

Prism.languages['edgeql-synopsis'] = Object.assign({}, shared_synopsis_grammar,
{
  'keyword':
    RegExp('\\b(?:[A-Z]{2,})\\b', 'i'),

});

Prism.languages['eschema-synopsis'] = Object.assign({}, \
shared_synopsis_grammar,
{
  'keyword':
    RegExp('\\b(?:' + eschema_keywords.join('|') + ')\\b'),
});
    '''.strip(' '))

    code = ''.join(code)

    if stdout:
        print(code, end='')
    else:
        with open(out_fn, 'wt') as f:
            f.write(code)


@edbcommands.command('gen-prism-grammars')
@click.option(
    '--stdout', type=bool, default=False, is_flag=True)
@click.option(
    '-f', '--file',
    type=str, default='auto-grammars.js', help='output grammar file name')
def gen_prism_grammars(*, stdout, file):
    """Generate the prism grammars for EdgeQL and eschema"""
    try:
        main(stdout=stdout, out_fn=file)
    except Exception as ex:
        die(str(ex))
