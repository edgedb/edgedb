##
# Copyright (c) 2016 MagicStack Inc.
# All rights reserved.
#
# See LICENSE for details.
##


CREATE MODULE std;
CREATE MODULE stdattrs;  # standard schema attributes need to be in a separate
                         # module to avoid name conflicts.

CREATE ABSTRACT ATOM std::any;
CREATE ATOM std::typeref;
CREATE ATOM std::atomref EXTENDING std::typeref;
CREATE ATOM std::conceptref EXTENDING std::typeref;

CREATE ATOM std::bytes;

CREATE ATOM std::datetime;

CREATE ATOM std::uuid;

CREATE ATOM std::str;

CREATE ATOM std::json;

CREATE ATOM std::timedelta;

CREATE ATOM std::date;

CREATE ATOM std::time;

CREATE ATOM std::int;

CREATE ATOM std::float;

CREATE ATOM std::bool;

CREATE ATTRIBUTE std::pattern std::str;

CREATE ABSTRACT ATOM std::sequence;

CREATE ATOM std::tsvector;
CREATE ATOM std::tsquery;

CREATE ATTRIBUTE stdattrs::precision array<std::int>;

CREATE ATTRIBUTE stdattrs::name std::str;
CREATE ATTRIBUTE stdattrs::is_abstract std::bool;
CREATE ATTRIBUTE stdattrs::is_final std::bool;
CREATE ATTRIBUTE stdattrs::is_derived std::bool;
CREATE ATTRIBUTE stdattrs::is_virtual std::bool;
CREATE ATTRIBUTE stdattrs::title std::str;
CREATE ATTRIBUTE stdattrs::description std::str;

CREATE ATTRIBUTE stdattrs::expr std::str;
CREATE ATTRIBUTE stdattrs::subjectexpr std::str;
CREATE ATTRIBUTE stdattrs::finalexpr std::str;
CREATE ATTRIBUTE stdattrs::errmessage std::str;

CREATE ATTRIBUTE stdattrs::value std::str;
CREATE ATTRIBUTE stdattrs::required std::bool;
CREATE ATTRIBUTE stdattrs::readonly std::bool;
CREATE ATTRIBUTE stdattrs::default std::str;
CREATE ATTRIBUTE stdattrs::expression std::str;
CREATE ATTRIBUTE stdattrs::exposed_behaviour std::str;
CREATE ATTRIBUTE stdattrs::mapping std::str;
CREATE ATTRIBUTE stdattrs::aggregate std::bool;
CREATE ATTRIBUTE stdattrs::set_returning std::bool;
CREATE ATTRIBUTE stdattrs::language std::str;
CREATE ATTRIBUTE stdattrs::code std::str;
CREATE ATTRIBUTE stdattrs::from_function std::str;
CREATE ATTRIBUTE stdattrs::initial_value std::str;
CREATE ATTRIBUTE stdattrs::varparam std::int;
CREATE ATTRIBUTE stdattrs::args map<std::str, std::str>;

CREATE FUNCTION std::lower(std::str) -> std::str
    FROM SQL FUNCTION 'lower';

CREATE AGGREGATE std::sum(std::int) -> std::int
    INITIAL VALUE 0
    FROM SQL AGGREGATE 'sum';

CREATE AGGREGATE std::sum(std::float) -> std::float
    INITIAL VALUE 0
    FROM SQL AGGREGATE 'sum';

CREATE AGGREGATE std::count(std::any) -> std::int
    INITIAL VALUE 0
    FROM SQL AGGREGATE 'count';

CREATE AGGREGATE std::array_agg(std::any) -> array<std::any>
    INITIAL VALUE []
    FROM SQL AGGREGATE 'array_agg';

CREATE AGGREGATE std::is_distinct(std::any) -> std::bool
    INITIAL VALUE True
    FROM SQL AGGREGATE '--system--';

CREATE FUNCTION std::array_unpack(array<std::any>) -> SET OF std::any
    FROM SQL FUNCTION '--system--';

CREATE FUNCTION std::array_contains(array<std::any>, std::any) -> std::bool
    FROM SQL $$
        SELECT
            CASE
                WHEN $2 IS NULL THEN NULL
                ELSE array_position($1, $2) IS NOT NULL
            END;
    $$;

CREATE FUNCTION std::array_enumerate(array<std::any>) ->
        SET OF tuple<std::any, std::int>
    FROM SQL FUNCTION '--system--';

CREATE FUNCTION std::len(std::str) -> std::int
    FROM SQL FUNCTION 'char_length';

CREATE FUNCTION std::len(std::bytes) -> std::int
    FROM SQL FUNCTION 'length';

CREATE FUNCTION std::len(array<std::any>) -> std::int
    FROM SQL $$
        SELECT array_length($1, 1)::bigint
    $$;

CREATE FUNCTION std::random() -> std::float
    FROM SQL FUNCTION 'random';

CREATE FUNCTION std::re_match(std::str, std::str) -> SET OF array<std::str>
    FROM SQL $$
        SELECT regexp_matches($1, $2);
    $$;

CREATE FUNCTION std::re_match_all(std::str, std::str) -> SET OF array<std::str>
    FROM SQL $$
        SELECT regexp_matches($1, $2, 'g');
    $$;

CREATE FUNCTION std::re_test(std::str, std::str) -> std::bool
    FROM SQL $$
        SELECT $1 ~ $2;
    $$;

CREATE FUNCTION std::current_date() -> std::date
    FROM SQL 'SELECT current_date';

CREATE FUNCTION std::current_time() -> std::time
    FROM SQL 'SELECT current_time';

CREATE FUNCTION std::current_datetime() -> std::datetime
    FROM SQL FUNCTION 'now';

CREATE FUNCTION std::uuid_generate_v1mc() -> std::uuid
    FROM SQL FUNCTION 'uuid_generate_v1mc';

CREATE CONSTRAINT std::constraint {
    SET errmessage := 'invalid {subject}';
};

CREATE CONSTRAINT std::expression EXTENDING std::constraint {
    SET expr := subject;
};

CREATE CONSTRAINT std::max(std::any) EXTENDING std::constraint {
    SET errmessage := 'Maximum allowed value for {subject} is {$0}.';
    SET expr := ((subject <= $0));
};

CREATE CONSTRAINT std::enum(array<std::any>) EXTENDING std::constraint {
    SET errmessage := '{subject} must be one of: {$0}.';
    SET expr := array_contains($0, subject);
};

CREATE CONSTRAINT std::min(std::any) EXTENDING std::constraint {
    SET errmessage := 'Minimum allowed value for {subject} is {$0}.';
    SET expr := ((subject >= $0));
};

CREATE CONSTRAINT std::minexclusive(std::any) EXTENDING std::min {
    SET errmessage := '{subject} must be greater than {$0}.';
    SET expr := ((subject > $0));
};

CREATE CONSTRAINT std::length ON (len(<std::str>subject))
    EXTENDING std::constraint
{
    SET errmessage := 'invalid {subject}';
};

CREATE CONSTRAINT std::minlength(std::any) EXTENDING (std::min, std::length) {
    SET errmessage := '{subject} must be no shorter than {$0} characters.';
};

CREATE CONSTRAINT std::regexp(std::any) EXTENDING std::constraint {
    SET errmessage := 'invalid {subject}';
    SET expr := re_test(subject, $0);
};

CREATE CONSTRAINT std::maxlength(std::any) EXTENDING (std::max, std::length) {
    SET errmessage := '{subject} must be no longer than {$0} characters.';
};

CREATE CONSTRAINT std::maxexclusive(std::any) EXTENDING std::max {
    SET errmessage := '{subject} must be less than {$0}.';
};

CREATE CONSTRAINT std::unique EXTENDING std::constraint {
    SET errmessage := '{subject} violates unique constraint';
    SET expr := std::is_distinct(ALL subject);
};

CREATE ATOM std::decimal_rounding_t EXTENDING std::str {
    CREATE CONSTRAINT std::enum(
        ['ceiling', '05up', 'up', 'half-even',
         'half-up', 'floor', 'down', 'half-down']);
};

CREATE ATTRIBUTE std::rounding std::decimal_rounding_t;

CREATE ATOM std::decimal;

CREATE ACTION std::restrict {
    SET title := 'Abort the event if a pointer exists';
};

CREATE ACTION std::cascade {
    SET title := 'Cascade the event through the pointer';
};

CREATE ACTION std::delete_pointer {
    SET title := 'Delete pointer';
};

CREATE ACTION std::ignore {
    SET title := 'Ignore the event';
};

CREATE ACTION std::delete_source {
    SET title := 'Delete pointer target';
};

CREATE ACTION std::delete_orphan_target {
    SET title := 'Delete target if no instances of the inbound pointer to it exist';
};

CREATE ACTION std::cascade_loaded {
    SET title := 'Cascade the event through the pointer if target is loaded to the local session';
};

CREATE ACTION std::delete_target {
    SET title := 'Delete pointer target';
};

CREATE EVENT std::event;

CREATE EVENT std::cascade_base EXTENDING std::event;

CREATE EVENT std::cascade_session_detach EXTENDING std::cascade_base;

CREATE EVENT std::cascade_serialize EXTENDING std::cascade_base;

CREATE EVENT std::internal EXTENDING std::event;

CREATE EVENT std::deleted EXTENDING std::internal;

CREATE EVENT std::source_deleted EXTENDING std::deleted;

CREATE EVENT std::self_deleted EXTENDING std::deleted;

CREATE EVENT std::cascade_session_attach EXTENDING std::cascade_base;

CREATE EVENT std::cascade_copy EXTENDING std::cascade_base;

CREATE EVENT std::target_deleted EXTENDING std::deleted;

CREATE LINK PROPERTY std::linkproperty {
    SET title := 'Base link property';
};

CREATE LINK PROPERTY std::source {
    SET title := 'Link source';
};

CREATE LINK PROPERTY std::target {
    SET title := 'Link target';
};

CREATE LINK PROPERTY std::linkid {
    SET title := 'Base link property';
};

CREATE LINK std::link {
    CREATE REQUIRED LINK PROPERTY std::linkid TO std::uuid {
        SET default := (SELECT std::uuid_generate_v1mc());
        SET readonly := True;
        SET title := 'Link ID';
    };
    CREATE POLICY FOR std::cascade_session_detach TO std::cascade_loaded;
    CREATE POLICY FOR std::cascade_serialize TO std::cascade_loaded;
    CREATE POLICY FOR std::source_deleted TO std::restrict;
    CREATE POLICY FOR std::self_deleted TO std::ignore;
    CREATE POLICY FOR std::cascade_session_attach TO std::cascade_loaded;
    CREATE POLICY FOR std::target_deleted TO std::restrict;
    CREATE POLICY FOR std::cascade_copy TO std::ignore;
};

CREATE LINK std::id EXTENDING std::link;

CREATE CONCEPT std::Object {
    CREATE REQUIRED LINK std::id TO std::uuid {
        SET default := (SELECT std::uuid_generate_v1mc());
        SET mapping := '11';
        SET readonly := True;
    };
};


# INTROSPECTION SCHEMA

CREATE MODULE schema;


CREATE ABSTRACT CONCEPT schema::Class {
    CREATE REQUIRED LINK schema::name TO std::str;
};


CREATE CONCEPT schema::Attribute EXTENDING schema::Class {
    CREATE LINK schema::type TO schema::Class;
};


CREATE LINK schema::attributes {
    CREATE LINK PROPERTY schema::value TO std::str;
};


ALTER CONCEPT schema::Class {
    CREATE LINK schema::attributes TO schema::Attribute {
        SET mapping := '**';
    };
};


CREATE LINK std::__class__ {
    SET readonly := True;
};


ALTER CONCEPT std::Object {
    CREATE LINK std::__class__ TO schema::Class {
        SET readonly := True;
    };
};


CREATE CONCEPT schema::Module EXTENDING schema::Class;


CREATE ABSTRACT CONCEPT schema::Node EXTENDING schema::Class;


CREATE CONCEPT schema::Array EXTENDING schema::Node {
    CREATE REQUIRED LINK schema::element_type TO schema::Node;
    CREATE LINK schema::dimensions TO array<std::int>;
};


CREATE CONCEPT schema::Map EXTENDING schema::Node {
    CREATE REQUIRED LINK schema::element_type TO schema::Node;
    CREATE REQUIRED LINK schema::key_type TO schema::Node;
};


CREATE CONCEPT schema::TypeElement {
    CREATE REQUIRED LINK schema::type TO schema::Node;
    CREATE REQUIRED LINK schema::num TO std::int;
    CREATE LINK schema::name TO std::str;
};


CREATE CONCEPT schema::Tuple EXTENDING schema::Node {
    CREATE REQUIRED LINK schema::element_types TO schema::TypeElement {
        SET mapping := '1*';
    };
};


CREATE CONCEPT schema::Delta EXTENDING schema::Class {
    CREATE LINK schema::parents TO schema::Delta {
        SET mapping := '**';
    };
};


CREATE ABSTRACT CONCEPT schema::InheritingClass EXTENDING schema::Class {
    CREATE LINK schema::bases TO schema::InheritingClass {
        SET mapping := '**';
    };

    CREATE LINK schema::mro TO schema::InheritingClass {
        SET mapping := '**';
    };

    CREATE LINK schema::is_abstract TO std::bool {
        SET default := false;
    };

    CREATE LINK schema::is_final TO std::bool {
        SET default := false;
    };
};


CREATE ABSTRACT CONCEPT schema::PrimaryClass
    EXTENDING schema::InheritingClass
{
    CREATE LINK schema::title TO std::str;
    CREATE LINK schema::description TO std::str;
};


CREATE CONCEPT schema::Parameter {
    CREATE REQUIRED LINK schema::type TO schema::Node;
    CREATE REQUIRED LINK schema::num TO std::int;
    CREATE LINK schema::name TO std::str;
    CREATE LINK schema::default TO std::str;
    CREATE LINK schema::variadic TO std::bool;
};


CREATE CONCEPT schema::Constraint EXTENDING schema::PrimaryClass {
    CREATE LINK schema::expr TO std::str;
    CREATE LINK schema::subjectexpr TO std::str;
    CREATE LINK schema::finalexpr TO std::str;
    CREATE LINK schema::errmessage TO std::str;
    CREATE LINK schema::params TO schema::Parameter {
        SET mapping := '**';
    };
    CREATE LINK schema::args TO map<std::str, std::str>;
};


CREATE ABSTRACT CONCEPT schema::ConsistencySubject EXTENDING schema::Class {
    CREATE LINK schema::constraints TO schema::Constraint {
        SET mapping := '**';
    };
};


CREATE CONCEPT schema::SourceIndex EXTENDING schema::Class {
    CREATE LINK schema::expr TO std::str;
};


CREATE ABSTRACT CONCEPT schema::Source EXTENDING schema::Class {
    CREATE LINK schema::indexes TO schema::SourceIndex {
        SET mapping := '1*';
    };
};


CREATE ABSTRACT CONCEPT schema::Pointer EXTENDING schema::Class;


CREATE CONCEPT schema::Atom EXTENDING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node) {
    CREATE LINK schema::default TO std::str;
};


CREATE CONCEPT schema::Concept EXTENDING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node,
         schema::Source);


CREATE CONCEPT schema::View EXTENDING
        (schema::PrimaryClass, schema::Source) {
    CREATE LINK schema::expr TO std::str;
};


CREATE CONCEPT schema::VirtualConcept EXTENDING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node,
         schema::Source);


CREATE CONCEPT schema::DerivedConcept EXTENDING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node,
         schema::Source);


CREATE CONCEPT schema::Link EXTENDING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Pointer,
         schema::Source);


CREATE CONCEPT schema::DerivedLink EXTENDING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Pointer,
         schema::Source);


CREATE CONCEPT schema::LinkProperty EXTENDING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Pointer);


ALTER CONCEPT schema::Pointer {
    CREATE LINK schema::source TO schema::Source;
    CREATE LINK schema::target TO schema::Node;
};


ALTER CONCEPT schema::Link {
    CREATE LINK schema::link_properties TO schema::LinkProperty {
        SET mapping := '1*';
    };
};


ALTER CONCEPT schema::Concept {
    CREATE LINK schema::links TO schema::Link {
        SET mapping := '1*';
    };
};


ALTER CONCEPT schema::View {
    CREATE LINK schema::links TO schema::Link {
        SET mapping := '1*';
    };
};


CREATE CONCEPT schema::Function EXTENDING schema::PrimaryClass {
    CREATE LINK schema::params TO schema::Parameter {
        SET mapping := '**';
    };
    CREATE LINK schema::returntype TO schema::Node;
    CREATE LINK schema::aggregate TO std::bool;
    CREATE LINK schema::set_returning TO std::bool;
};
