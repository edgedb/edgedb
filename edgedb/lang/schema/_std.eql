##
# Copyright (c) 2016 MagicStack Inc.
# All rights reserved.
#
# See LICENSE for details.
##


CREATE MODULE std;
CREATE MODULE stdattrs;  # standard schema attributes need to be in a separate
                         # module to avoid name conflicts.

CREATE ABSTRACT SCALAR TYPE std::any;

CREATE SCALAR TYPE std::bytes;

CREATE SCALAR TYPE std::datetime;

CREATE SCALAR TYPE std::uuid;

CREATE SCALAR TYPE std::str;

CREATE SCALAR TYPE std::json;

CREATE SCALAR TYPE std::timedelta;

CREATE SCALAR TYPE std::date;

CREATE SCALAR TYPE std::time;

CREATE SCALAR TYPE std::int;

CREATE SCALAR TYPE std::float;

CREATE SCALAR TYPE std::bool;

CREATE ATTRIBUTE std::pattern std::str;

CREATE ABSTRACT SCALAR TYPE std::sequence;

CREATE SCALAR TYPE std::tsvector;
CREATE SCALAR TYPE std::tsquery;

CREATE ATTRIBUTE stdattrs::precision array<std::int>;

CREATE ATTRIBUTE stdattrs::name std::str;
CREATE ATTRIBUTE stdattrs::is_abstract std::bool;
CREATE ATTRIBUTE stdattrs::is_final std::bool;
CREATE ATTRIBUTE stdattrs::is_derived std::bool;
CREATE ATTRIBUTE stdattrs::is_virtual std::bool;
CREATE ATTRIBUTE stdattrs::view_type std::int;
CREATE ATTRIBUTE stdattrs::title std::str;
CREATE ATTRIBUTE stdattrs::description std::str;

CREATE ATTRIBUTE stdattrs::expr std::str;
CREATE ATTRIBUTE stdattrs::subjectexpr std::str;
CREATE ATTRIBUTE stdattrs::finalexpr std::str;
CREATE ATTRIBUTE stdattrs::errmessage std::str;

CREATE ATTRIBUTE stdattrs::value std::str;
CREATE ATTRIBUTE stdattrs::required std::bool;
CREATE ATTRIBUTE stdattrs::readonly std::bool;
CREATE ATTRIBUTE stdattrs::computable std::bool;
CREATE ATTRIBUTE stdattrs::default std::str;
CREATE ATTRIBUTE stdattrs::expression std::str;
CREATE ATTRIBUTE stdattrs::mapping std::str;
CREATE ATTRIBUTE stdattrs::aggregate std::bool;
CREATE ATTRIBUTE stdattrs::set_returning std::bool;
CREATE ATTRIBUTE stdattrs::language std::str;
CREATE ATTRIBUTE stdattrs::code std::str;
CREATE ATTRIBUTE stdattrs::from_function std::str;
CREATE ATTRIBUTE stdattrs::initial_value std::str;
CREATE ATTRIBUTE stdattrs::varparam std::int;
CREATE ATTRIBUTE stdattrs::args map<std::str, std::str>;

CREATE FUNCTION std::lower(std::str) -> std::str
    FROM SQL FUNCTION 'lower';

CREATE FUNCTION std::sum(SET OF std::int) -> std::int {
    INITIAL VALUE 0;
    FROM SQL FUNCTION 'sum';
};

CREATE FUNCTION std::sum(SET OF std::float) -> std::float {
    INITIAL VALUE 0;
    FROM SQL FUNCTION 'sum';
};

CREATE FUNCTION std::count(SET OF std::any) -> std::int {
    INITIAL VALUE 0;
    FROM SQL FUNCTION 'count';
};

CREATE FUNCTION std::array_agg(SET OF std::any) -> array<std::any> {
    INITIAL VALUE [];
    FROM SQL FUNCTION 'array_agg';
};

CREATE FUNCTION std::is_distinct(SET OF std::any) -> std::bool {
    INITIAL VALUE True;
    FROM SQL FUNCTION '--system--';
};

CREATE FUNCTION std::array_unpack(array<std::any>) -> SET OF std::any
    FROM SQL FUNCTION '--system--';

CREATE FUNCTION std::array_contains(array<std::any>, std::any) -> std::bool
    FROM SQL $$
        SELECT
            CASE
                WHEN $2 IS NULL THEN NULL
                ELSE array_position($1, $2) IS NOT NULL
            END;
    $$;

CREATE FUNCTION std::array_enumerate(array<std::any>) ->
        SET OF tuple<std::any, std::int>
    FROM SQL FUNCTION '--system--';

CREATE FUNCTION std::len(std::str) -> std::int
    FROM SQL FUNCTION 'char_length';

CREATE FUNCTION std::len(std::bytes) -> std::int
    FROM SQL FUNCTION 'length';

CREATE FUNCTION std::len(array<std::any>) -> std::int
    FROM SQL $$
        SELECT array_length($1, 1)::bigint
    $$;

CREATE FUNCTION std::random() -> std::float
    FROM SQL FUNCTION 'random';

CREATE FUNCTION std::re_match(std::str, std::str) -> array<std::str>
    FROM SQL $$
        SELECT regexp_matches($1, $2);
    $$;

CREATE FUNCTION std::re_match_all(std::str, std::str) -> SET OF array<std::str>
    FROM SQL $$
        SELECT regexp_matches($1, $2, 'g');
    $$;

CREATE FUNCTION std::re_test(std::str, std::str) -> std::bool
    FROM SQL $$
        SELECT $1 ~ $2;
    $$;

CREATE FUNCTION std::current_date() -> std::date
    FROM SQL 'SELECT current_date';

CREATE FUNCTION std::current_time() -> std::time
    FROM SQL 'SELECT current_time';

CREATE FUNCTION std::current_datetime() -> std::datetime
    FROM SQL FUNCTION 'now';

CREATE FUNCTION std::uuid_generate_v1mc() -> std::uuid
    FROM SQL FUNCTION 'uuid_generate_v1mc';

CREATE CONSTRAINT std::constraint {
    SET errmessage := 'invalid {__subject__}';
};

CREATE CONSTRAINT std::expression EXTENDING std::constraint {
    SET expr := __subject__;
};

CREATE CONSTRAINT std::max(std::any) EXTENDING std::constraint {
    SET errmessage := 'Maximum allowed value for {__subject__} is {$0}.';
    SET expr := __subject__ <= $0;
};

CREATE CONSTRAINT std::enum(array<std::any>) EXTENDING std::constraint {
    SET errmessage := '{__subject__} must be one of: {$0}.';
    SET expr := array_contains($0, __subject__);
};

CREATE CONSTRAINT std::min(std::any) EXTENDING std::constraint {
    SET errmessage := 'Minimum allowed value for {__subject__} is {$0}.';
    SET expr := __subject__ >= $0;
};

CREATE CONSTRAINT std::minexclusive(std::any) EXTENDING std::min {
    SET errmessage := '{__subject__} must be greater than {$0}.';
    SET expr := __subject__ > $0;
};

CREATE CONSTRAINT std::length ON (len(<std::str>__subject__))
    EXTENDING std::constraint
{
    SET errmessage := 'invalid {__subject__}';
};

CREATE CONSTRAINT std::minlength(std::any) EXTENDING (std::min, std::length) {
    SET errmessage := '{__subject__} must be no shorter than {$0} characters.';
};

CREATE CONSTRAINT std::regexp(std::any) EXTENDING std::constraint {
    SET errmessage := 'invalid {__subject__}';
    SET expr := re_test(__subject__, $0);
};

CREATE CONSTRAINT std::maxlength(std::any) EXTENDING (std::max, std::length) {
    SET errmessage := '{__subject__} must be no longer than {$0} characters.';
};

CREATE CONSTRAINT std::maxexclusive(std::any) EXTENDING std::max {
    SET errmessage := '{__subject__} must be less than {$0}.';
};

CREATE CONSTRAINT std::unique EXTENDING std::constraint {
    SET errmessage := '{__subject__} violates unique constraint';
    SET expr := std::is_distinct(__subject__);
};

CREATE SCALAR TYPE std::decimal_rounding_t EXTENDING std::str {
    CREATE CONSTRAINT std::enum(
        ['ceiling', '05up', 'up', 'half-even',
         'half-up', 'floor', 'down', 'half-down']);
};

CREATE ATTRIBUTE std::rounding std::decimal_rounding_t;

CREATE SCALAR TYPE std::decimal;

CREATE ACTION std::restrict {
    SET title := 'Abort the event if a pointer exists';
};

CREATE ACTION std::cascade {
    SET title := 'Cascade the event through the pointer';
};

CREATE ACTION std::delete_pointer {
    SET title := 'Delete pointer';
};

CREATE ACTION std::ignore {
    SET title := 'Ignore the event';
};

CREATE ACTION std::delete_source {
    SET title := 'Delete pointer target';
};

CREATE ACTION std::delete_orphan_target {
    SET title := 'Delete target if no instances of the inbound pointer to it exist';
};

CREATE ACTION std::cascade_loaded {
    SET title := 'Cascade the event through the pointer if target is loaded to the local session';
};

CREATE ACTION std::delete_target {
    SET title := 'Delete pointer target';
};

CREATE EVENT std::event;

CREATE EVENT std::cascade_base EXTENDING std::event;

CREATE EVENT std::cascade_session_detach EXTENDING std::cascade_base;

CREATE EVENT std::cascade_serialize EXTENDING std::cascade_base;

CREATE EVENT std::internal EXTENDING std::event;

CREATE EVENT std::deleted EXTENDING std::internal;

CREATE EVENT std::source_deleted EXTENDING std::deleted;

CREATE EVENT std::self_deleted EXTENDING std::deleted;

CREATE EVENT std::cascade_session_attach EXTENDING std::cascade_base;

CREATE EVENT std::cascade_copy EXTENDING std::cascade_base;

CREATE EVENT std::target_deleted EXTENDING std::deleted;

CREATE LINK PROPERTY std::linkproperty {
    SET title := 'Base link property';
};

CREATE LINK PROPERTY std::source {
    SET title := 'Link source';
};

CREATE LINK PROPERTY std::target {
    SET title := 'Link target';
};

CREATE LINK std::link {
    CREATE POLICY FOR std::cascade_session_detach TO std::cascade_loaded;
    CREATE POLICY FOR std::cascade_serialize TO std::cascade_loaded;
    CREATE POLICY FOR std::source_deleted TO std::restrict;
    CREATE POLICY FOR std::self_deleted TO std::ignore;
    CREATE POLICY FOR std::cascade_session_attach TO std::cascade_loaded;
    CREATE POLICY FOR std::target_deleted TO std::restrict;
    CREATE POLICY FOR std::cascade_copy TO std::ignore;
};

CREATE LINK std::id EXTENDING std::link;

CREATE TYPE std::Object {
    CREATE REQUIRED LINK std::id TO std::uuid {
        SET default := (SELECT std::uuid_generate_v1mc());
        SET mapping := '11';
        SET readonly := True;
    };
};


# INTROSPECTION SCHEMA

CREATE MODULE schema;


# Base type for all schema entities.
CREATE ABSTRACT TYPE schema::Object {
    CREATE REQUIRED LINK schema::name TO std::str;
    CREATE LINK schema::description TO std::str;
};


# Base type for all *types*.
CREATE ABSTRACT TYPE schema::Type EXTENDING schema::Object;


CREATE TYPE schema::Attribute EXTENDING schema::Object {
    CREATE LINK schema::type TO schema::Type;
};


CREATE LINK schema::attributes {
    CREATE LINK PROPERTY schema::value TO std::str;
};


ALTER TYPE schema::Object {
    CREATE LINK schema::attributes TO schema::Attribute {
        SET mapping := '**';
    };
};


CREATE LINK std::__type__ {
    SET readonly := True;
};


ALTER TYPE std::Object {
    CREATE LINK std::__type__ TO schema::Type {
        SET readonly := True;
    };
};


CREATE TYPE schema::Module EXTENDING schema::Object;


CREATE ABSTRACT TYPE schema::ContainerType EXTENDING schema::Type;


CREATE TYPE schema::Array EXTENDING schema::ContainerType {
    CREATE REQUIRED LINK schema::element_type TO schema::Type;
    CREATE LINK schema::dimensions TO array<std::int>;
};


CREATE TYPE schema::Map EXTENDING schema::ContainerType {
    CREATE REQUIRED LINK schema::element_type TO schema::Type;
    CREATE REQUIRED LINK schema::key_type TO schema::Type;
};


CREATE TYPE schema::TypeElement {
    CREATE REQUIRED LINK schema::type TO schema::Type;
    CREATE REQUIRED LINK schema::num TO std::int;
    CREATE LINK schema::name TO std::str;
};


CREATE TYPE schema::Tuple EXTENDING schema::ContainerType {
    CREATE REQUIRED LINK schema::element_types TO schema::TypeElement {
        SET mapping := '1*';
    };
};


CREATE TYPE schema::Delta EXTENDING schema::Object {
    CREATE LINK schema::parents TO schema::Delta {
        SET mapping := '**';
    };
};


CREATE ABSTRACT TYPE schema::InheritingObject EXTENDING schema::Object {
    CREATE LINK schema::bases TO schema::InheritingObject {
        SET mapping := '**';
    };

    CREATE LINK schema::mro TO schema::InheritingObject {
        SET mapping := '**';
    };

    CREATE LINK schema::is_abstract TO std::bool {
        SET default := false;
    };

    CREATE LINK schema::is_final TO std::bool {
        SET default := false;
    };
};


CREATE TYPE schema::Parameter {
    CREATE REQUIRED LINK schema::type TO schema::Type;
    CREATE REQUIRED LINK schema::kind TO std::str;
    CREATE REQUIRED LINK schema::num TO std::int;
    CREATE LINK schema::name TO std::str;
    CREATE LINK schema::default TO std::str;
    CREATE LINK schema::variadic TO std::bool;
};


CREATE TYPE schema::Constraint EXTENDING schema::InheritingObject {
    CREATE LINK schema::expr TO std::str;
    CREATE LINK schema::subjectexpr TO std::str;
    CREATE LINK schema::finalexpr TO std::str;
    CREATE LINK schema::errmessage TO std::str;
    CREATE LINK schema::params TO schema::Parameter {
        SET mapping := '**';
    };
    CREATE LINK schema::args TO map<std::str, std::str>;
};


CREATE ABSTRACT TYPE schema::ConsistencySubject EXTENDING schema::Object {
    CREATE LINK schema::constraints TO schema::Constraint {
        SET mapping := '**';
    };
};


CREATE TYPE schema::SourceIndex EXTENDING schema::Object {
    CREATE LINK schema::expr TO std::str;
};


CREATE ABSTRACT TYPE schema::Source EXTENDING schema::Object {
    CREATE LINK schema::indexes TO schema::SourceIndex {
        SET mapping := '1*';
    };
};


CREATE ABSTRACT TYPE schema::Pointer EXTENDING schema::Object;


CREATE TYPE schema::ScalarType EXTENDING
        (schema::InheritingObject, schema::ConsistencySubject, schema::Type) {
    CREATE LINK schema::default TO std::str;
};


CREATE TYPE schema::ObjectType EXTENDING
        (schema::InheritingObject, schema::ConsistencySubject, schema::Type,
         schema::Source);


CREATE TYPE schema::UnionObjectType EXTENDING
        (schema::InheritingObject, schema::ConsistencySubject, schema::Type,
         schema::Source);


CREATE TYPE schema::DerivedObjectType EXTENDING
        (schema::InheritingObject, schema::ConsistencySubject, schema::Type,
         schema::Source);


CREATE TYPE schema::Link EXTENDING
        (schema::InheritingObject, schema::ConsistencySubject, schema::Pointer,
         schema::Source);


CREATE TYPE schema::DerivedLink EXTENDING
        (schema::InheritingObject, schema::ConsistencySubject, schema::Pointer,
         schema::Source);


CREATE TYPE schema::LinkProperty EXTENDING
        (schema::InheritingObject, schema::ConsistencySubject, schema::Pointer);


ALTER TYPE schema::Pointer {
    CREATE LINK schema::source TO schema::Source;
    CREATE LINK schema::target TO schema::Type;
};


ALTER TYPE schema::Link {
    CREATE LINK schema::link_properties TO schema::LinkProperty {
        SET mapping := '1*';
    };
};


ALTER TYPE schema::ObjectType {
    CREATE LINK schema::links TO schema::Link {
        SET mapping := '1*';
    };
};


CREATE TYPE schema::Function EXTENDING schema::Object {
    CREATE LINK schema::params TO schema::Parameter {
        SET mapping := '**';
    };
    CREATE LINK schema::returntype TO schema::Type;
    CREATE LINK schema::aggregate TO std::bool;
    CREATE LINK schema::set_returning TO std::bool;
};
