##
# Copyright (c) 2016 MagicStack Inc.
# All rights reserved.
#
# See LICENSE for details.
##


CREATE MODULE std;
CREATE MODULE stdattrs;  # standard schema attributes need to be in a separate
                         # module to avoid name conflicts.

CREATE ABSTRACT ATOM std::any;
CREATE ATOM std::typeref;
CREATE ATOM std::atomref INHERITING std::typeref;
CREATE ATOM std::conceptref INHERITING std::typeref;

CREATE ATOM std::bytes;

CREATE ATOM std::datetime;

CREATE ATOM std::uuid;

CREATE ATOM std::str;

CREATE ATOM std::json;

CREATE ATOM std::timedelta;

CREATE ATOM std::date;

CREATE ATOM std::time;

CREATE ATOM std::int;

CREATE ATOM std::float;

CREATE ATOM std::bool;

CREATE ATTRIBUTE std::pattern std::str;

CREATE ABSTRACT ATOM std::sequence;

CREATE ATOM std::tsvector;
CREATE ATOM std::tsquery;

CREATE ATTRIBUTE stdattrs::precision array<std::int>;

CREATE ATTRIBUTE stdattrs::name std::str;
CREATE ATTRIBUTE stdattrs::is_abstract std::bool;
CREATE ATTRIBUTE stdattrs::is_final std::bool;
CREATE ATTRIBUTE stdattrs::is_derived std::bool;
CREATE ATTRIBUTE stdattrs::is_virtual std::bool;
CREATE ATTRIBUTE stdattrs::title std::str;
CREATE ATTRIBUTE stdattrs::description std::str;

CREATE ATTRIBUTE stdattrs::expr std::str;
CREATE ATTRIBUTE stdattrs::subjectexpr std::str;
CREATE ATTRIBUTE stdattrs::finalexpr std::str;
CREATE ATTRIBUTE stdattrs::errmessage std::str;

CREATE ATTRIBUTE stdattrs::value std::str;
CREATE ATTRIBUTE stdattrs::required std::bool;
CREATE ATTRIBUTE stdattrs::readonly std::bool;
CREATE ATTRIBUTE stdattrs::default std::str;
CREATE ATTRIBUTE stdattrs::expression std::str;
CREATE ATTRIBUTE stdattrs::exposed_behaviour std::str;
CREATE ATTRIBUTE stdattrs::mapping std::str;
CREATE ATTRIBUTE stdattrs::aggregate std::bool;
CREATE ATTRIBUTE stdattrs::set_returning std::bool;
CREATE ATTRIBUTE stdattrs::language std::str;
CREATE ATTRIBUTE stdattrs::code std::str;
CREATE ATTRIBUTE stdattrs::from_function std::str;
CREATE ATTRIBUTE stdattrs::initial_value std::str;
CREATE ATTRIBUTE stdattrs::varparam std::int;
CREATE ATTRIBUTE stdattrs::args map<std::str, std::str>;

CREATE FUNCTION std::lower(std::str) RETURNING std::str
    FROM SQL FUNCTION 'lower';

CREATE AGGREGATE std::sum(std::int)
    RETURNING std::int
    INITIAL VALUE 0
    FROM SQL AGGREGATE 'sum';

CREATE AGGREGATE std::count(std::any)
    RETURNING std::int
    INITIAL VALUE 0
    FROM SQL AGGREGATE 'count';

CREATE AGGREGATE std::array_agg(std::any)
    RETURNING array<std::any>
    INITIAL VALUE []
    FROM SQL AGGREGATE 'array_agg';

CREATE AGGREGATE std::is_distinct(std::any)
    RETURNING std::bool
    INITIAL VALUE True
    FROM SQL AGGREGATE '--system--';

CREATE FUNCTION std::array_unpack(array<std::any>)
    RETURNING SET OF std::any
    FROM SQL FUNCTION '--system--';

CREATE FUNCTION std::array_contains(array<std::any>, std::any)
    RETURNING std::bool
    FROM SQL $$
        SELECT
            CASE
                WHEN $2 IS NULL THEN NULL
                ELSE array_position($1, $2) IS NOT NULL
            END;
    $$;

CREATE FUNCTION std::array_enumerate(array<std::any>)
    RETURNING SET OF tuple<std::any, std::int>
    FROM SQL FUNCTION '--system--';

CREATE FUNCTION std::len(std::str) RETURNING std::int
    FROM SQL FUNCTION 'char_length';

CREATE FUNCTION std::len(std::bytes) RETURNING std::int
    FROM SQL FUNCTION 'length';

CREATE FUNCTION std::len(array<std::any>) RETURNING std::int
    FROM SQL $$
        SELECT array_length($1, 1)::bigint
    $$;

CREATE FUNCTION std::random() RETURNING std::float
    FROM SQL FUNCTION 'random';

CREATE FUNCTION std::to_tsquery(std::str) RETURNING std::tsquery
    FROM SQL FUNCTION 'to_tsquery';

CREATE FUNCTION std::to_tsvector(std::str) RETURNING std::tsvector
    FROM SQL FUNCTION 'to_tsvector';

CREATE CONSTRAINT std::constraint {
    SET errmessage := 'invalid {subject}';
};

CREATE CONSTRAINT std::expression INHERITING std::constraint {
    SET expr := subject;
};

CREATE CONSTRAINT std::max INHERITING std::constraint {
    SET errmessage := 'Maximum allowed value for {subject} is {param}.';
    SET expr := ((subject <= $param));
};

CREATE CONSTRAINT std::enum INHERITING std::constraint {
    SET errmessage := '{subject} must be one of: {param}.';
    SET expr := array_contains($param, subject);
};

CREATE CONSTRAINT std::min INHERITING std::constraint {
    SET errmessage := 'Minimum allowed value for {subject} is {param}.';
    SET expr := ((subject >= $param));
};

CREATE CONSTRAINT std::minexclusive INHERITING std::min {
    SET errmessage := '{subject} must be greater than {param}.';
    SET expr := ((subject > $param));
};

CREATE CONSTRAINT std::length INHERITING std::constraint {
    SET errmessage := 'invalid {subject}';
    SET subjectexpr := (len(<std::str>subject));
};

CREATE CONSTRAINT std::minlength INHERITING (std::min, std::length) {
    SET errmessage := '{subject} must be no shorter than {param} characters.';
};

CREATE CONSTRAINT std::regexp INHERITING std::constraint {
    SET errmessage := 'invalid {subject}';
    SET expr := ((subject ~ $param));
};

CREATE CONSTRAINT std::maxlength INHERITING (std::max, std::length) {
    SET errmessage := '{subject} must be no longer than {param} characters.';
};

CREATE CONSTRAINT std::maxexclusive INHERITING std::max {
    SET errmessage := '{subject} must be less than {param}.';
};

CREATE CONSTRAINT std::unique INHERITING std::constraint {
    SET errmessage := '{subject} violates unique constraint';
    SET expr := std::is_distinct(ALL subject);
};

CREATE ATOM std::decimal_rounding_t INHERITING std::str {
    CREATE CONSTRAINT std::enum {
        SET args := (param := ['ceiling', '05up', 'up', 'half-even',
                               'half-up', 'floor', 'down', 'half-down']);
    };
};

CREATE ATTRIBUTE std::rounding std::decimal_rounding_t;

CREATE ATOM std::decimal;

CREATE FUNCTION std::current_date() RETURNING std::date
    FROM SQL 'SELECT current_date';

CREATE FUNCTION std::current_time() RETURNING std::time
    FROM SQL 'SELECT current_time';

CREATE FUNCTION std::current_datetime() RETURNING std::datetime
    FROM SQL FUNCTION 'now';

CREATE FUNCTION std::uuid_generate_v1mc() RETURNING std::uuid
    FROM SQL FUNCTION 'uuid_generate_v1mc';

CREATE ACTION std::restrict {
    SET title := 'Abort the event if a pointer exists';
};

CREATE ACTION std::cascade {
    SET title := 'Cascade the event through the pointer';
};

CREATE ACTION std::delete_pointer {
    SET title := 'Delete pointer';
};

CREATE ACTION std::ignore {
    SET title := 'Ignore the event';
};

CREATE ACTION std::delete_source {
    SET title := 'Delete pointer target';
};

CREATE ACTION std::delete_orphan_target {
    SET title := 'Delete target if no instances of the inbound pointer to it exist';
};

CREATE ACTION std::cascade_loaded {
    SET title := 'Cascade the event through the pointer if target is loaded to the local session';
};

CREATE ACTION std::delete_target {
    SET title := 'Delete pointer target';
};

CREATE EVENT std::event;

CREATE EVENT std::cascade_base INHERITING std::event;

CREATE EVENT std::cascade_session_detach INHERITING std::cascade_base;

CREATE EVENT std::cascade_serialize INHERITING std::cascade_base;

CREATE EVENT std::internal INHERITING std::event;

CREATE EVENT std::deleted INHERITING std::internal;

CREATE EVENT std::source_deleted INHERITING std::deleted;

CREATE EVENT std::self_deleted INHERITING std::deleted;

CREATE EVENT std::cascade_session_attach INHERITING std::cascade_base;

CREATE EVENT std::cascade_copy INHERITING std::cascade_base;

CREATE EVENT std::target_deleted INHERITING std::deleted;

CREATE LINK PROPERTY std::linkproperty {
    SET title := 'Base link property';
};

CREATE LINK PROPERTY std::source {
    SET title := 'Link source';
};

CREATE LINK PROPERTY std::target {
    SET title := 'Link target';
};

CREATE LINK PROPERTY std::linkid {
    SET title := 'Base link property';
};

CREATE LINK std::link {
    CREATE REQUIRED LINK PROPERTY std::linkid TO std::uuid {
        SET default := (SELECT std::uuid_generate_v1mc());
        SET readonly := True;
        SET title := 'Link ID';
    };
    CREATE POLICY FOR std::cascade_session_detach TO std::cascade_loaded;
    CREATE POLICY FOR std::cascade_serialize TO std::cascade_loaded;
    CREATE POLICY FOR std::source_deleted TO std::restrict;
    CREATE POLICY FOR std::self_deleted TO std::ignore;
    CREATE POLICY FOR std::cascade_session_attach TO std::cascade_loaded;
    CREATE POLICY FOR std::target_deleted TO std::restrict;
    CREATE POLICY FOR std::cascade_copy TO std::ignore;
};

CREATE LINK std::id INHERITING std::link;

CREATE CONCEPT std::Object {
    CREATE REQUIRED LINK std::id TO std::uuid {
        SET default := (SELECT std::uuid_generate_v1mc());
        SET mapping := '11';
        SET readonly := True;
    };
};


# INTROSPECTION SCHEMA

CREATE MODULE schema;


CREATE ABSTRACT CONCEPT schema::Class {
    CREATE REQUIRED LINK schema::name TO std::str;
};


CREATE CONCEPT schema::Attribute INHERITING schema::Class {
    CREATE LINK schema::type TO schema::Class;
};


CREATE LINK schema::attributes {
    CREATE LINK PROPERTY schema::value TO std::str;
};


ALTER CONCEPT schema::Class {
    CREATE LINK schema::attributes TO schema::Attribute {
        SET mapping := '**';
    };
};


CREATE LINK std::__class__ {
    SET readonly := True;
};


ALTER CONCEPT std::Object {
    CREATE LINK std::__class__ TO schema::Class {
        SET readonly := True;
    };
};


CREATE CONCEPT schema::Module INHERITING schema::Class;


CREATE ABSTRACT CONCEPT schema::Node INHERITING schema::Class;


CREATE CONCEPT schema::Array INHERITING schema::Node {
    CREATE REQUIRED LINK schema::element_type TO schema::Node;
    CREATE LINK schema::dimensions TO array<std::int>;
};


CREATE CONCEPT schema::Map INHERITING schema::Node {
    CREATE REQUIRED LINK schema::element_type TO schema::Node;
    CREATE REQUIRED LINK schema::key_type TO schema::Node;
};


CREATE CONCEPT schema::TypeElement {
    CREATE REQUIRED LINK schema::type TO schema::Node;
    CREATE REQUIRED LINK schema::num TO std::int;
    CREATE LINK schema::name TO std::str;
};


CREATE CONCEPT schema::Tuple INHERITING schema::Node {
    CREATE REQUIRED LINK schema::element_types TO schema::TypeElement {
        SET mapping := '1*';
    };
};


CREATE CONCEPT schema::Delta INHERITING schema::Class {
    CREATE LINK schema::parents TO schema::Delta {
        SET mapping := '**';
    };
};


CREATE ABSTRACT CONCEPT schema::InheritingClass INHERITING schema::Class {
    CREATE LINK schema::bases TO schema::InheritingClass {
        SET mapping := '**';
    };

    CREATE LINK schema::mro TO schema::InheritingClass {
        SET mapping := '**';
    };

    CREATE LINK schema::is_abstract TO std::bool {
        SET default := false;
    };

    CREATE LINK schema::is_final TO std::bool {
        SET default := false;
    };
};


CREATE ABSTRACT CONCEPT schema::PrimaryClass
    INHERITING schema::InheritingClass
{
    CREATE LINK schema::title TO std::str;
    CREATE LINK schema::description TO std::str;
};


CREATE CONCEPT schema::Constraint INHERITING schema::PrimaryClass {
    CREATE LINK schema::expr TO std::str;
    CREATE LINK schema::subjectexpr TO std::str;
    CREATE LINK schema::finalexpr TO std::str;
    CREATE LINK schema::errmessage TO std::str;
    CREATE LINK schema::paramtypes TO schema::TypeElement {
        SET mapping := '1*';
    };
    CREATE LINK schema::inferredparamtypes TO schema::TypeElement {
        SET mapping := '1*';
    };
    CREATE LINK schema::args TO map<std::str, std::str>;
};


CREATE ABSTRACT CONCEPT schema::ConsistencySubject INHERITING schema::Class {
    CREATE LINK schema::constraints TO schema::Constraint {
        SET mapping := '**';
    };
};


CREATE CONCEPT schema::SourceIndex INHERITING schema::Class {
    CREATE LINK schema::expr TO std::str;
};


CREATE ABSTRACT CONCEPT schema::Source INHERITING schema::Class {
    CREATE LINK schema::indexes TO schema::SourceIndex {
        SET mapping := '1*';
    };
};


CREATE ABSTRACT CONCEPT schema::Pointer INHERITING schema::Class;


CREATE CONCEPT schema::Atom INHERITING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node) {
    CREATE LINK schema::default TO std::str;
};


CREATE CONCEPT schema::Concept INHERITING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node,
         schema::Source);


CREATE CONCEPT schema::View INHERITING
        (schema::PrimaryClass, schema::Source) {
    CREATE LINK schema::expr TO std::str;
};


CREATE CONCEPT schema::VirtualConcept INHERITING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node,
         schema::Source);


CREATE CONCEPT schema::DerivedConcept INHERITING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Node,
         schema::Source);


CREATE CONCEPT schema::Link INHERITING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Pointer,
         schema::Source);


CREATE CONCEPT schema::DerivedLink INHERITING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Pointer,
         schema::Source);


CREATE CONCEPT schema::LinkProperty INHERITING
        (schema::PrimaryClass, schema::ConsistencySubject, schema::Pointer);


ALTER CONCEPT schema::Pointer {
    CREATE LINK schema::source TO schema::Source;
    CREATE LINK schema::target TO schema::Node;
};


ALTER CONCEPT schema::Link {
    CREATE LINK schema::link_properties TO schema::LinkProperty {
        SET mapping := '1*';
    };
};


ALTER CONCEPT schema::Concept {
    CREATE LINK schema::links TO schema::Link {
        SET mapping := '1*';
    };
};


ALTER CONCEPT schema::View {
    CREATE LINK schema::links TO schema::Link {
        SET mapping := '1*';
    };
};


CREATE CONCEPT schema::FunctionParameter {
    CREATE REQUIRED LINK schema::type TO schema::Node;
    CREATE REQUIRED LINK schema::num TO std::int;
    CREATE LINK schema::name TO std::str;
    CREATE LINK schema::default TO std::str;
    CREATE LINK schema::variadic TO std::bool;
};


CREATE CONCEPT schema::Function INHERITING schema::PrimaryClass {
    CREATE LINK schema::params TO schema::FunctionParameter {
        SET mapping := '**';
    };
    CREATE LINK schema::returntype TO schema::Node;
    CREATE LINK schema::aggregate TO std::bool;
    CREATE LINK schema::set_returning TO std::bool;
};
